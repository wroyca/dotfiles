#+Title: GNU Emacs
#+Startup: overview

This document describes my GNU Emacs configuration. You may use =C-c C-v t= to tangle each section automatically, or optionally, evaluate the following code block:

#+begin_src emacs-lisp :tangle no :results none
  (org-babel-tangle)
#+end_src

-----

#+begin_src emacs-lisp :tangle "init.el"
  ;;; -*- mode: emacs-lisp; lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; -*- mode: emacs-lisp; lexical-binding: t -*-
#+end_src

* Early Initialization

Prior to Emacs 27, the init file was responsible for invoking [[elisp:(describe-symbol 'package-initialize)][package-initialize]] to set up the package manager. With Emacs 27, this behavior changed: [[elisp:(describe-symbol 'package-initialize)][package-initialize]] is now called automatically before loading the init file. This means we need to ensure that package requests are not preempted by the dependencies they rely on.

#+begin_src emacs-lisp :tangle "early-init.el" :noweb yes
  (defun dotemacs//before-init-hook (&rest _args)
    ;; Ensure package requests are not preempted by the dependencies they rely on.
    (setq package-enable-at-startup nil)
    ;; Prevent premature redisplay.
    <<inhibit-redisplay>>)

  (add-hook 'before-init-hook 'dotemacs//before-init-hook)
#+end_src

* Initialization

Emacs doesn't recommend that we move into ~~early-init.el~~ customizations that can be left in ~~init.el~~. That is because the early init file is read before the GUI is initialized, so customizations related to GUI features will not work reliably in ~~early-init.el~~. By contrast, the /normal/ init files are read after the GUI is initialized. Instead, the recommanded approach for customizations that rely on GUI features is to make them run off hooks provided by the Emacs startup, such as [[elisp:(describe-symbol 'package-initialize)][window-setup-hook]] or [[elisp:(describe-symbol 'package-initialize)][tty-setup-hook]].

#+begin_src emacs-lisp :tangle "init.el" :noweb yes
  (defun dotemacs//tty-setup-hook (&rest _args)
    <<inhibit-startup-screen>>
    <<inhibit-startup-area-message>>
    <<initial-scratch-message>>)

  (add-hook 'tty-setup-hook 'dotemacs//tty-setup-hook)

  ;; Note: `tty-setup-hook' does not run while redisplay is
  ;; inhibited. It will trigger only after we lift the inhibition, which
  ;; is "too late" to hide the elements below.
  (mapc (lambda (mode) (funcall mode -1))
        '(menu-bar-mode scroll-bar-mode tool-bar-mode))
#+end_src

** Inhibit
*** Startup Screen

#+name: inhibit-startup-screen
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src

*** Startup Echo Area Message

https://yrh.dev/blog/rant-obfuscation-in-emacs/

#+name: inhibit-startup-area-message
#+begin_src emacs-lisp
  (setq inhibit-startup-echo-area-message (user-login-name))
  (put 'inhibit-startup-echo-area-message 'saved-value t)
#+end_src

*** Redisplay

#+name: inhibit-redisplay
#+begin_src emacs-lisp
  (setq-default inhibit-redisplay t)
#+end_src

** Scratch

At startup, the *scratch* buffer contains a short message, in the form of a Lisp comment, that explains what it is for. This message is controlled by the [[elisp:(describe-symbol 'initial-scratch-message)][initial-scratch-message]] variable, which should be either a documentation string, or nil (which means to suppress the message).

#+name: initial-scratch-message
#+begin_src emacs-lisp
  ;; Suppress the *scratch* buffer short message
  (setq initial-scratch-message nil)
#+end_src

** Load Theme

According to [[elisp:(describe-symbol 'load-theme)][load-theme]] description, when a theme is enabled in Emacs, it doesn’t automatically disable any other active themes. This means the newly enabled theme takes precedence and can sometimes cause subtle appearance changes that are hard to trace. For users unfamiliar with Emacs, this might even give the impression that the theme is "broken", as I experienced myself.

A better approach is to disable any previously [[elisp:(describe-symbol 'custom-enabled-themes)][active themes]] before applying a new one. This can be achieved by advising [[elisp:(describe-symbol 'load-theme)][load-theme]] beforehand. /(I sure wish I had known about this sooner…)/

#+begin_src emacs-lisp :tangle "init.el"
  (defun dotemacs//disable-themes (&rest _args)
    (mapc #'disable-theme custom-enabled-themes))

  (advice-add #'load-theme :before #'dotemacs//disable-themes)
#+end_src

#+begin_src emacs-lisp :tangle "init.el"
  (load-theme 'modus-vivendi-tinted)
#+end_src

** XTerm

*** Mouse

 NOTE: This is extremely primitive.

#+begin_src emacs-lisp :tangle "init.el"
  (xterm-mouse-mode)

  ;; TODO: Terminals handle scrolling differently (e.g., Kitty's default is
  ;; to scroll by 4, Ptyxis by 1, and so on). For now, set the default
  ;; as if using Ptyxis, but later detect the terminal properly.
  (setq mouse-wheel-scroll-amount '(3 ((shift) . 5) ((control) . nil)))
  (setq mouse-wheel-progressive-speed nil)
  (setq scroll-margin 4)
#+end_src

*** Operating System Command (OSC)

Modern terminals can send and receive Operating System Command (OSC) codes. In practice, this refers to the sequence of two ASCII characters: ~27~ and ~93 (ESC ])~. If the command takes ~parameters~, it will be followed by a semicolon, and the structure of the rest of the OSC sequence depends on the command. Well-behaved terminal emulators ignore OSC codes with unrecognized commands.

Continuing forward, the string terminator (ST) ends an OSC sequence and consists of either two ASCII characters: ~27~ and ~92 (ESC )~ or—now deprecated—ASCII ~7 (BEL)~. The ~parameters~ (Ps) consist of a single (usually optional) numeric parameter, which is composed of one or more decimal digits.

The XTerm specification states that the 10 colors listed below may be set or queried using codes 10 through 19. These are referred to as dynamic colors, as the corresponding control sequences were the first means for setting xterm's colors dynamically, i.e., after it was started. They are not the same as the ANSI colors; However, dynamic text foreground and background colors are used when ANSI colors are reset using SGR 39 and 49, respectively.

| Resource                 | Description                                |
|--------------------------+--------------------------------------------|
| Ps = 1 0                 |  Change VT100 text foreground color to Pt. |
| Ps = 1 1                 |  Change VT100 text background color to Pt. |
| Ps = 1 2                 |  Change text cursor color to Pt.           |
| Ps = 1 3                 |  Change pointer foreground color to Pt.    |
| Ps = 1 4                 |  Change pointer background color to Pt.    |
| Ps = 1 5                 |  Change Tektronix foreground color to Pt.  |
| Ps = 1 6                 |  Change Tektronix background color to Pt.  |
| Ps = 1 7                 |  Change highlight background color to Pt.  |
| Ps = 1 8                 |  Change Tektronix cursor color to Pt.      |
| Ps = 1 9                 |  Change highlight foreground color to Pt.  |

Here we advise load-theme to send an ANSI escape sequence to the terminal to update the background color according to the current frame's background-color parameter. Moreover, we advise Emacs to reset the terminal background to its default state upon exit.

https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands

#+begin_src emacs-lisp :tangle "init.el"
  (defun dotemacs//xterm-change-text-background (&rest _args)
    (send-string-to-terminal
     (format "\e]11;%s\a" (frame-parameter nil 'background-color))))

  (advice-add #'load-theme :after #'dotemacs//xterm-change-text-background)
  (add-hook 'resume-tty-functions #'dotemacs//xterm-change-text-background)

  ;; Run once as pre-shot routine.
  (dotemacs//xterm-change-text-background)
#+end_src

Dynamic colors can also be reset to their default.

| Resource                 | Description                        |
|--------------------------+------------------------------------|
| Ps = 1 1 0               | Reset VT100 text foreground color. |
| Ps = 1 1 1               | Reset VT100 text background color. |
| Ps = 1 1 2               | Reset text cursor color.           |
| Ps = 1 1 3               | Reset pointer foreground color.    |
| Ps = 1 1 4               | Reset pointer background color.    |
| Ps = 1 1 5               | Reset Tektronix foreground color.  |
| Ps = 1 1 6               | Reset Tektronix background color.  |
| Ps = 1 1 7               | Reset highlight color.             |
| Ps = 1 1 8               | Reset Tektronix cursor color.      |
| Ps = 1 1 9               | Reset highlight foreground color.  |

#+begin_src emacs-lisp :tangle "init.el"
  (defun dotemacs//xterm-reset-text-background (&rest _args)
    (send-string-to-terminal "\e]111;\a"))

  (add-hook 'kill-emacs-hook #'dotemacs//xterm-reset-text-background)
  (add-hook 'suspend-tty-functions #'dotemacs//xterm-reset-text-background)
#+end_src

If necessary, OSC compatibility can be tested as follows:

#+begin_src emacs-lisp :tangle no :results none
  (defun dotemacs//xterm-parse-osc11 ()
    "Check if our Terminal supports OSC 11.
  Sends an OSC 11 query and returns the response if the terminal supports it,
  otherwise returns nil."
    (send-string-to-terminal "\e]11;?\e\\")
    (when (and (equal (read-event nil nil 2) ?\e)
	       (equal (read-event nil nil 2) ?\]))
      (let ((response ""))
	(while (not (equal (setq chr (read-event nil nil 2)) ?\\))
	  (setq response (concat response (string chr))))
	(when (string-match
	       "11;rgb:\\([a-f0-9]+\\)/\\([a-f0-9]+\\)/\\([a-f0-9]+\\)" response)
	  response))))
#+end_src

*** Ptyxis

Fedora 41 now ships Ptyxis as its default terminal. Thankfully, Ptyxis comes with proper instance detection and some convenient command-line arguments to, for example, create a new tab on an already existing instance. We can use that to wrap Emacs with Ptyxis.

Note: This is extremely experimental and was created quickly as a demonstration. It will improve over time.

#+begin_src emacs-lisp :tangle "init.el"
  (defvar dotemacs--ptyxis-open-files '()
    "List of files currently opened in Ptyxis tabs.")

  (defun dotemacs//ptyxis-generate-tab-command (file)
    "Generate the command to open FILE in a new Ptyxis tab with Emacs client."
    (let ((title (concat (file-name-nondirectory file) " - ")))
      (format "/home/wroy/.local/bin/ptyxis/emacs-new-tab %s %s"
              (shell-quote-argument title)
              (shell-quote-argument file))))

  (defun dotemacs/ptyxis-open-file-in-tab (file)
    "Open FILE in a new Ptyxis tab and launch new Emacs client.
  The file is also added to `dotemacs--ptyxis-open-files` for reopening
  purposes."
    (interactive "FFile: ")
    (let ((cmd (dotemacs//ptyxis-generate-tab-command file)))
      (start-process-shell-command "ptyxis-open-file" nil cmd)
      (add-to-list 'dotemacs--ptyxis-open-files file)))

  (defun dotemacs/ptyxis-reopen-tabs ()
    "Reopen all files listed in `dotemacs--ptyxis-open-files` in new Ptyxis
  tabs.
  Use this function if a GTK crash occurs or tabs need to be restored."
    (interactive)
    (dolist (file dotemacs--ptyxis-open-files)
      (dotemacs/ptyxis-open-file-in-tab file)))

  (defun dotemacs//ptyxis-open-file-advice (orig-fun &rest args)
    "Advice to open files in a new Ptyxis tab by default.
  ORIG-FUN is the original function, and ARGS are its arguments."
    (if (bound-and-true-p org-babel-exp-reference-buffer)
        ;; Avoid creating a Ptyxis tab when org-babel-exp-reference-buffer
        ;; is bound. That is, files are temporarily opened to write tangled
        ;; code, and attempting to forward them to a new tab will cancel the
        ;; tangle process.
        (apply orig-fun args)
      (let ((file (car args)))
        (if (and file (file-exists-p file) (not (file-directory-p file)))
            (dotemacs/ptyxis-open-file-in-tab file)
          (apply orig-fun args)))))

  (advice-add 'find-file :around #'dotemacs//ptyxis-open-file-advice)
  (advice-add 'dired-find-file :around #'dotemacs//ptyxis-open-file-advice)
#+end_src

** Settings

*** Minibuffer

Support for opening new minibuffer while already using an active minibuffer. Note that by default, the outer-level minibuffer is invisible while we are editing the inner one.

#+begin_src emacs-lisp :tangle "init.el"
  (setq enable-recursive-minibuffers t)
#+end_src

Display the current level of minibuffer recursion depth directly in the prompt

#+begin_src emacs-lisp :tangle "init.el"
  (setq minibuffer-depth-indicate-mode t)
#+end_src

Prevent cursor from entering minibuffer prompt area

#+begin_src emacs-lisp :tangle "init.el"
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

*** Prompt indicator

Enhance the prompt indicator for `completing-read-multiple' to display [CRM<separator>] (e.g., [CRM,] when using a comma as the separator).

#+begin_src emacs-lisp :tangle "init.el"
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
  		(replace-regexp-in-string
  		 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
  		 crm-separator)
  		(car args))
  	(cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
#+end_src

*** Savehist

#+begin_src emacs-lisp :tangle "init.el"
  (savehist-mode)
#+end_src

*** Cua Mode

My Keyboard is not ready right now, so we can't focus on Meow at the moment.

#+begin_src emacs-lisp :tangle "init.el"
  (cua-mode)
#+end_src

*** Editorconfig

#+begin_src emacs-lisp :tangle "init.el"
  (editorconfig-mode)
#+end_src

* Packages
** Elpaca
#+begin_src emacs-lisp :tangle "init.el"
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                   ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                   ,@(when-let ((depth (plist-get order :depth)))
                                                       (list (format "--depth=%d" depth) "--no-single-branch"))
                                                   ,(plist-get order :repo) ,repo))))
                   ((zerop (call-process "git" nil buffer t "checkout"
                                         (or (plist-get order :ref) "--"))))
                   (emacs (concat invocation-directory invocation-name))
                   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                         "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                   ((require 'elpaca))
                   ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+end_src

*** Install use-package support

#+begin_src emacs-lisp :tangle "init.el"
(elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
  (elpaca-use-package-mode))
#+end_src

** Doom Modeline
#+begin_src emacs-lisp :tangle "init.el"
  (use-package doom-modeline
    :ensure (:wait t)
    :init
    (doom-modeline-mode)
    :custom
    (doom-modeline-icon nil)
    :config
    ;; Re-enable redisplay
    (setq inhibit-redisplay nil)
    (redisplay t)) ;; Force immediate redisplay
#+end_src

** Vertico

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico
    :ensure t
    :hook
    (elpaca-after-init . vertico-mode))
#+end_src

*** Vertico Buffer

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-buffer
    :after vertico)
#+end_src

*** Vertico Directory

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-directory
    :after vertico
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    ;; Tidy shadowed file names
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

*** Vertico Flat

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-flat
    :after vertico)
#+end_src

*** Vertico Grid

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-grid
    :after vertico)
#+end_src

*** Vertico Indexed

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-indexed
    :after vertico)
#+end_src

*** Vertico Mouse

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-mouse
    :after vertico
    :hook
    (vertico-mode . vertico-mouse-mode))
#+end_src

*** Vertico Multiform

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-multiform
    :after vertico)
#+end_src

*** Vertico Quick

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-quick
    :after vertico)
#+end_src

*** Vertico Repeat

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-repeat
    :after vertico)
#+end_src

*** Vertico Reverse

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-reverse
    :after vertico)
#+end_src

*** Vertico Suspend

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-suspend
    :after vertico)
#+end_src

*** Vertico Unobstrusive

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-unobtrusive
    :after vertico)
#+end_src

** Marginalia

#+begin_src emacs-lisp :tangle "init.el"
  (use-package marginalia
    :ensure t
    :hook
    (vertico-mode . marginalia-mode))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle "init.el"
  (use-package consult
    :ensure t)
#+end_src

** Embark

#+begin_src emacs-lisp :tangle "init.el"
  (use-package embark
    :ensure t)
#+end_src

*** Embark Consult

#+begin_src emacs-lisp :tangle "init.el"
  (use-package embark-consult
    :ensure t)
#+end_src

** Orderless

#+begin_src emacs-lisp :tangle "init.el"
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Transient

#+begin_src emacs-lisp :tangle "init.el"
  (use-package transient
    :ensure t)
#+end_src

** Magit

#+begin_src emacs-lisp :tangle "init.el"
  (use-package magit
     :ensure t
     :custom
     (magit-no-message (list "Turning on magit-auto-revert-mode..."))
     (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
     :hook
     (after-save . magit-after-save-refresh-status))
#+end_src

*** Magit Delta

#+begin_src emacs-lisp :tangle "init.el"
  (use-package magit-delta
     :ensure t
     :after magit
     :hook (magit-mode . magit-delta-mode))
#+end_src

** Forge

#+begin_src emacs-lisp :tangle "init.el"
  (use-package forge
    :ensure t
    :after magit
    :config
    (setq auth-sources '("~/.authinfo")))
#+end_src

** Org

#+begin_src emacs-lisp :tangle "init.el"
  (use-package org
    :ensure t)
#+end_src

*** Modern

#+begin_src emacs-lisp :tangle "init.el"
  (use-package org-modern
    :ensure t
    :hook
    (org-mode . org-modern-mode))
#+end_src

** XClip

#+begin_src emacs-lisp :tangle "init.el"
  (use-package xclip
    :ensure t
    :custom
    (xclip-mode 1))
#+end_src

** Undofu

#+begin_src emacs-lisp :tangle "init.el"
  (use-package undo-fu-session
    :ensure t
    :custom
    (undo-fu-session-global-mode 1))
#+end_src

* Language Server Protocol

#+begin_src emacs-lisp :tangle "init.el"
  (use-package eglot
    :custom
    (eglot-ignored-server-capabilities '(:documentHighlightProvider))

    :config
    (add-to-list 'eglot-server-programs
                 '((c-mode c++-mode)
                   . ("clangd"
                      "--all-scopes-completion=true"
                      "--background-index-priority=normal"
                      "--background-index=true"
                      "--clang-tidy"
                      "--completion-parse=always"
                      "--completion-style=bundled"
                      "--function-arg-placeholders=false"
                      "--header-insertion=never"
                      "--parse-forwarding-functions"
                      "--pch-storage=memory"
                      "--ranking-model=decision_forest")))

    :hook
    ((c-mode c++-mode) . eglot-ensure))

  (use-package clangd-inactive-regions
    :ensure (:host github :repo "fargiolas/clangd-inactive-regions.el")
    :init
    ;; FIXME: Using `:hook' behave strangely. (lisp recursion?)
    (add-hook 'eglot-managed-mode-hook #'clangd-inactive-regions-mode)
    :config
    (clangd-inactive-regions-set-method "darken-foreground")
    (clangd-inactive-regions-set-opacity 0.55))
#+end_src

** Completion
#+begin_src emacs-lisp :tangle "init.el"
  (use-package company
    :ensure t
    :bind (:map company-active-map
        	      ([tab] . company-complete-selection)
        	      ("TAB" . company-complete-selection)
        	      ("<return>" . nil)
        	      ("RET" . nil))
    :custom
    ;; "Tooltip" is misleading; this actually refers to the completion
    ;; menu.
    (company-tooltip-limit 8)
    (company-tooltip-align-annotations t)

    ;; Instructs company to allow typing characters that don't match any
    ;; completion candidates. When non-nil, typing characters not in the
    ;; auto-completion list is restricted.
    (company-require-match nil)

    ;; XXX: We might want to set the prefix length and idle delay based
    ;; on the language. Clangd is very fast, so it's not a concern, but
    ;; what about slower LSP clients?
    (company-minimum-prefix-length 1)
    (company-idle-delay 0)

    ;; Disable icons.
    (company-format-margin-function nil)

    ;; In the Emacs’s world, the current tendency is to have the
    ;; completion logic provided by completion-at-point-functions (CAPF)
    ;; implementations. [Among the other things, this is what the
    ;; popular packages that support language server protocol (LSP) also
    ;; rely on.]
    ;;
    ;; Since company-capf works as a bridge to the standard CAPF
    ;; facility, it is probably the most often used and recommended
    ;; backend nowadays, including for Emacs Lisp coding.
    ;;
    ;; To illustrate, the following minimal backends setup already cover
    ;; a large number of basic use cases, especially so in major modes
    ;; that have CAPF support implemented.
    (company-backends '(company-capf))

    ;; Collect candidates from the buffers with the same major mode.
    (company-dabbrev-other-buffers t)

    (global-company-mode 1))
#+end_src
