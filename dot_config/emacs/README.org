#+Title: GNU Emacs
#+Startup: overview

This document describes my GNU Emacs configuration. You may use =C-c C-v t= to tangle each section automatically, or optionally, evaluate the following code block:

#+begin_src emacs-lisp :tangle no :results none
  (org-babel-tangle)
#+end_src

#+begin_src emacs-lisp :tangle "init.el"
  ;;; -*- mode: emacs-lisp; lexical-binding: t -*-
#+end_src

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; -*- mode: emacs-lisp; lexical-binding: t -*-
#+end_src

* Early Initialization

Prior to Emacs 27, the init file was responsible for invoking [[elisp:(describe-symbol 'package-initialize)][package-initialize]] to set up the package manager. With Emacs 27, this behavior changed: [[elisp:(describe-symbol 'package-initialize)][package-initialize]] is now called automatically before loading the init file. This means we need to ensure that package requests are not preempted by the dependencies they rely on.

#+begin_src emacs-lisp :tangle "early-init.el" :noweb yes
  (defun dotemacs//before-init-hook (&rest _args)
    (setq package-enable-at-startup nil))
#+end_src

#+begin_src emacs-lisp :tangle "early-init.el"
  (add-hook 'before-init-hook 'dotemacs//before-init-hook)
#+end_src

* Initialization

Emacs do not recommend that we move into early-init.el customizations that can be left in the normal init files. That is because the early init file is read before the GUI is initialized, so customizations related to GUI features will not work reliably in early-init.el. By contrast, the normal init files are read after the GUI is initialized. Instead, their recommanded approach for customizations that rely on GUI features is to make them run off hooks provided by the Emacs startup, such as `window-setup-hook' or `tty-setup-hook'.

#+begin_src emacs-lisp :tangle "init.el" :noweb yes
  <<lumen>>

  (defun dotemacs//tty-setup-hook (&rest _args)
    (setq inhibit-startup-echo-area-message (user-login-name)
	  inhibit-startup-screen t)
    (put 'inhibit-startup-echo-area-message 'saved-value t)
    (setq initial-scratch-message nil)

    (mapc (lambda (mode) (funcall mode -1))
	  '(menu-bar-mode scroll-bar-mode tool-bar-mode))
    (setq-default mode-line-format nil))
#+end_src

#+begin_src emacs-lisp :tangle "init.el"
  (add-hook 'tty-setup-hook 'dotemacs//tty-setup-hook)
#+end_src

** Savehist

#+begin_src emacs-lisp :tangle "init.el"
  (savehist-mode)
#+end_src

** Minibuffer

Support opening new minibuffers from inside existing minibuffers.

#+begin_src emacs-lisp :tangle "init.el"
  (setq enable-recursive-minibuffers t)
#+end_src

Show the current recursion depth in the minibuffer prompt on recursive use of the minibuffer.

#+begin_src emacs-lisp :tangle "init.el"
  (setq minibuffer-depth-indicate-mode t)
#+end_src

Do not allow the cursor in the minibuffer prompt.

#+begin_src emacs-lisp :tangle "init.el"
  (setq minibuffer-prompt-properties
	'(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

** Prompt indicator

Enhance the prompt indicator for `completing-read-multiple' to display [CRM<separator>] (e.g., [CRM,] when using a comma as the separator).

#+begin_src emacs-lisp :tangle "init.el"
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
		  (replace-regexp-in-string
		   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
		   crm-separator)
		  (car args))
	  (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
#+end_src

** Load-theme

According to the description of [[elisp:(describe-symbol 'load-theme)][load-theme]], when a theme is enabled in Emacs, it doesn’t automatically disable any other active themes. This means the newly enabled theme takes precedence and can sometimes cause subtle appearance changes that are hard to trace. For users unfamiliar with Emacs, this might even give the impression that the theme is "broken", as I experienced myself.

A better approach is to disable any previously [[elisp:(describe-symbol 'custom-enabled-themes)][active themes]] before applying a new one. This can be achieved by advising [[elisp:(describe-symbol 'load-theme)][load-theme]] beforehand. /(I sure wish I had known about this sooner…)/

#+begin_src emacs-lisp :tangle "init.el"
  (defun dotemacs//disable-themes (&rest _args)
    (mapc #'disable-theme custom-enabled-themes))
  (advice-add #'load-theme :before #'dotemacs//disable-themes)
#+end_src

** XTerm

#+begin_src emacs-lisp :tangle "init.el"
  (xterm-mouse-mode)
#+end_src

*** Operating System Command (OSC)

Modern terminals can send and receive Operating System Command (OSC) codes. In practice, this refers to the sequence of two ASCII characters: ~27~ and ~93 (ESC ])~. If the command takes ~parameters~, it will be followed by a semicolon, and the structure of the rest of the OSC sequence depends on the command. Well-behaved terminal emulators ignore OSC codes with unrecognized commands.

Continuing forward, the string terminator (ST) ends an OSC sequence and consists of either two ASCII characters: ~27~ and ~92 (ESC )~ or—now deprecated—ASCII ~7 (BEL)~. The ~parameters~ (Ps) consist of a single (usually optional) numeric parameter, which is composed of one or more decimal digits.

The XTerm specification states that the 10 colors listed below may be set or queried using codes 10 through 19. These are referred to as dynamic colors, as the corresponding control sequences were the first means for setting xterm's colors dynamically, i.e., after it was started. They are not the same as the ANSI colors; However, dynamic text foreground and background colors are used when ANSI colors are reset using SGR 39 and 49, respectively.

| Resource                 | Description                                |
|--------------------------+--------------------------------------------|
| Ps = 1 0                 |  Change VT100 text foreground color to Pt. |
| Ps = 1 1                 |  Change VT100 text background color to Pt. |
| Ps = 1 2                 |  Change text cursor color to Pt.           |
| Ps = 1 3                 |  Change pointer foreground color to Pt.    |
| Ps = 1 4                 |  Change pointer background color to Pt.    |
| Ps = 1 5                 |  Change Tektronix foreground color to Pt.  |
| Ps = 1 6                 |  Change Tektronix background color to Pt.  |
| Ps = 1 7                 |  Change highlight background color to Pt.  |
| Ps = 1 8                 |  Change Tektronix cursor color to Pt.      |
| Ps = 1 9                 |  Change highlight foreground color to Pt.  |

Here we advise load-theme to send an ANSI escape sequence to the terminal to update the background color according to the current frame's background-color parameter. Moreover, we advise Emacs to reset the terminal background to its default state upon exit.

https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands

#+begin_src emacs-lisp :tangle "init.el"
  (defun dotemacs//xterm-change-text-background (&rest _args)
    (send-string-to-terminal
     (format "\e]11;%s\a" (frame-parameter nil 'background-color))))
  (advice-add #'load-theme :after #'dotemacs//xterm-change-text-background)
  (add-hook 'resume-tty-functions #'dotemacs//xterm-change-text-background)
  (dotemacs//xterm-change-text-background)
#+end_src

Dynamic colors can also be reset to their default.

| Resource                 | Description                        |
|--------------------------+------------------------------------|
| Ps = 1 1 0               | Reset VT100 text foreground color. |
| Ps = 1 1 1               | Reset VT100 text background color. |
| Ps = 1 1 2               | Reset text cursor color.           |
| Ps = 1 1 3               | Reset pointer foreground color.    |
| Ps = 1 1 4               | Reset pointer background color.    |
| Ps = 1 1 5               | Reset Tektronix foreground color.  |
| Ps = 1 1 6               | Reset Tektronix background color.  |
| Ps = 1 1 7               | Reset highlight color.             |
| Ps = 1 1 8               | Reset Tektronix cursor color.      |
| Ps = 1 1 9               | Reset highlight foreground color.  |

#+begin_src emacs-lisp :tangle "init.el"
  (defun dotemacs//xterm-reset-text-background (&rest _args)
    (send-string-to-terminal "\e]111;\a"))
  (add-hook 'kill-emacs-hook #'dotemacs//xterm-reset-text-background)
  (add-hook 'suspend-tty-functions #'dotemacs//xterm-reset-text-background)
#+end_src

Note that, if necessary, OSC compatibility can be tested as follows:

#+begin_src emacs-lisp :tangle no :results none
  (defun dotemacs//xterm-parse-osc11 ()
    "Check if our Terminal supports OSC 11.
  Sends an OSC 11 query and returns the response if the terminal supports it,
  otherwise returns nil."
    (send-string-to-terminal "\e]11;?\e\\")
    (when (and (equal (read-event nil nil 2) ?\e)
	       (equal (read-event nil nil 2) ?\]))
      (let ((response ""))
	(while (not (equal (setq chr (read-event nil nil 2)) ?\\))
	  (setq response (concat response (string chr))))
	(when (string-match
	       "11;rgb:\\([a-f0-9]+\\)/\\([a-f0-9]+\\)/\\([a-f0-9]+\\)" response)
	  response))))
#+end_src

** Active Process

Stop asking "Active processes exist; kill them and exit anyway" since we're monitoring dbus in the background.

#+begin_src emacs-lisp :tangle "init.el"
  (require 'cl-lib)

  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (cl-letf (((symbol-function #'process-list) (lambda ())))
      ad-do-it))
#+end_src

* Packages
** Elpaca

#+begin_src emacs-lisp :tangle "init.el"
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
				:ref nil :depth 1
				:files (:defaults "elpaca-test.el" (:exclude "extensions"))
				:build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
	 (build (expand-file-name "elpaca/" elpaca-builds-directory))
	 (order (cdr elpaca-order))
	 (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
	  (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
		   ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
						   ,@(when-let ((depth (plist-get order :depth)))
						       (list (format "--depth=%d" depth) "--no-single-branch"))
						   ,(plist-get order :repo) ,repo))))
		   ((zerop (call-process "git" nil buffer t "checkout"
					 (or (plist-get order :ref) "--"))))
		   (emacs (concat invocation-directory invocation-name))
		   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
					 "--eval" "(byte-recompile-directory \".\" 0 'force)")))
		   ((require 'elpaca))
		   ((elpaca-generate-autoloads "elpaca" repo)))
	      (progn (message "%s" (buffer-string)) (kill-buffer buffer))
	    (error "%s" (with-current-buffer buffer (buffer-string))))
	((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
  (elpaca elpaca-use-package
    (elpaca-use-package-mode))
#+end_src

** Meow

#+begin_src emacs-lisp :tangle "init.el"
   (use-package meow
    :ensure t
    :demand t
    :config
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-colemak-dh)
    (meow-motion-overwrite-define-key
     ;; Use e to move up, n to move down.
     ;; Since special modes usually use n to move down, we only overwrite e here.
     '("e" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     '("?" . meow-cheatsheet)
     ;; To execute the originally e in MOTION state, use SPC e.
     '("e" . "H-e")
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("1" . meow-expand-1)
     '("2" . meow-expand-2)
     '("3" . meow-expand-3)
     '("4" . meow-expand-4)
     '("5" . meow-expand-5)
     '("6" . meow-expand-6)
     '("7" . meow-expand-7)
     '("8" . meow-expand-8)
     '("9" . meow-expand-9)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("/" . meow-visit)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("e" . meow-prev)
     '("E" . meow-prev-expand)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-right)
     '("I" . meow-right-expand)
     '("j" . meow-join)
     '("k" . meow-kill)
     '("l" . meow-line)
     '("L" . meow-goto-line)
     '("m" . meow-mark-word)
     '("M" . meow-mark-symbol)
     '("n" . meow-next)
     '("N" . meow-next-expand)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("r" . meow-replace)
     '("s" . meow-insert)
     '("S" . meow-open-above)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-search)
     '("w" . meow-next-word)
     '("W" . meow-next-symbol)
     '("x" . meow-delete)
     '("X" . meow-backward-delete)
     '("y" . meow-save)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore))
    ;; Meow!
    (meow-global-mode 1))
#+end_src

** Vertico

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico
    :ensure t
    :hook
    (elpaca-after-init . vertico-mode))
#+end_src

*** Vertico Buffer

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-buffer
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Directory

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-directory
    :after vertico
    :ensure nil
    ;; More convenient directory navigation commands
    :bind (:map vertico-map
		("RET" . vertico-directory-enter)
		("DEL" . vertico-directory-delete-char)
		("M-DEL" . vertico-directory-delete-word))
    ;; Tidy shadowed file names
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

*** Vertico Flat

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-flat
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Grid

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-grid
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Indexed

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-indexed
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Mouse

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-mouse
    :after vertico
    :ensure nil
    :hook
    (vertico-mode . vertico-mouse-mode))
#+end_src

*** Vertico Multiform

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-multiform
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Quick

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-quick
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Repeat

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-repeat
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Reverse

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-reverse
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Suspend

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-suspend
    :after vertico
    :ensure nil)
#+end_src

*** Vertico Unobstrusive

#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico-unobtrusive
    :after vertico
    :ensure nil)
#+end_src

** Marginalia

#+begin_src emacs-lisp :tangle "init.el"
  (use-package marginalia
    :ensure t
    :hook
    (vertico-mode . marginalia-mode))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle "init.el"
  (use-package consult
    :ensure t)
#+end_src

** Embark

#+begin_src emacs-lisp :tangle "init.el"
  (use-package embark
    :ensure t)
#+end_src

*** Embark Consult

#+begin_src emacs-lisp :tangle "init.el"
  (use-package embark-consult
    :ensure t)
#+end_src

** Orderless

#+begin_src emacs-lisp :tangle "init.el"
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Transient

#+begin_src emacs-lisp :tangle "init.el"
  (use-package transient
    :ensure t)
#+end_src

** Magit

#+begin_src emacs-lisp :tangle "init.el"
  (use-package magit
    :ensure t
    :init
    (setq magit-no-message '("Turning on magit-auto-revert-mode..."))
    :custom
    (list `(,(expand-file-name "~/Projects/") . 1))
    :hook
    ;; Automatically refresh Magit buffers
    ;; NOTE: Can lead to a noticeable delay in big repositories.
    (after-save . magit-after-save-refresh-status)
    :config
    (magit-save-repository-buffers 'dontask))
#+end_src

*** Magit Delta

#+begin_src emacs-lisp :tangle "init.el"
  (use-package magit-delta
    :ensure t
    :after magit
    :hook (magit-mode . magit-delta-mode))
#+end_src

** Forge

#+begin_src emacs-lisp :tangle "init.el"
  (use-package forge
    :ensure t
    :after magit
    :config
    (setq auth-sources '("~/.authinfo")))
#+end_src

** Org

#+begin_src emacs-lisp :tangle "init.el"
  (use-package org
    :ensure t)
#+end_src

*** Modern

#+begin_src emacs-lisp :tangle "init.el"
  (use-package org-modern
    :ensure t
    :hook
    (org-mode . org-modern-mode))
#+end_src

** Moodline

#+begin_src emacs-lisp :tangle "init.el"
  (use-package mood-line
    :ensure t
    :init
    (mood-line-mode))
#+end_src

* Language Server Protocol

#+begin_src emacs-lisp :tangle "init.el"
  (use-package eglot
    :config
    ;; Disable "bold/highlight" ish effect on token under cursor
    (setq eglot-ignored-server-capabilites '(:documentHighlightProvider))
    (add-to-list 'eglot-server-programs '((sh-mode bash-ts-mode) . ("bash-language-server" "start")))
    (add-to-list 'eglot-server-programs '((c-mode c++-mode) . ("clangd"
							       "--all-scopes-completion=true"
							       "--background-index-priority=normal"
							       "--background-index=true"
							       "--clang-tidy"
							       "--completion-parse=always"
							       "--completion-style=bundled"
							       "--function-arg-placeholders=false"
							       "--header-insertion=never"
							       "--parse-forwarding-functions"
							       "--pch-storage=memory"
							       "--ranking-model=decision_forest")))
    :hook
    ((sh-mode
      bash-ts-mode
      c-mode
      c++-mode) . eglot-ensure))
#+end_src

** Completion

#+begin_src emacs-lisp :tangle "init.el"
  (use-package company
    :ensure t
    :bind
    (:map company-active-map
	  ([tab] . company-complete-selection)
	  ("TAB"    . company-complete-selection)
	  ("<return>" . nil)
	  ("RET" . nil))
    :init
    (setq company-minimum-prefix-length 1
	company-idle-delay 0
	company-format-margin-function nil
	company-backends '(company-capf)

	;; Only search the current buffer for `company-dabbrev' (a backend that
	;; suggests text your open buffers). This prevents Company from causing
	;; lag once you have a lot of buffers open.
	company-dabbrev-other-buffers nil

	;; Make `company-dabbrev' fully case-sensitive, to improve UX with
	;; domain-specific words with particular casing.
	company-dabbrev-ignore-case nil
	company-dabbrev-downcase nil)
    (global-company-mode))
#+end_src

* Debug Adapter Protocol
* Gist
* Experimental
** Lumen

Quickly put together hackish partial vim-lumen "port" from Vimscript to Elisp. I want to revisit this properly at some point.

https://github.com/vimpostor/vim-lumen
#+name: lumen
#+begin_src emacs-lisp
  (defvar lumen-background "")

  (defvar lumen-exit-code -1
    "Last job exit code.")

  (defvar lumen-lines nil
    "List to store output from job.")

  (defvar lumen-elines nil
    "List to store error output from job.")

  (defvar lumen-watched-line "/org/freedesktop/portal/desktop: org.freedesktop.portal.Settings.SettingChanged ('org.freedesktop.appearance', 'color-scheme', <uint32 "
    "Line pattern to watch for D-Bus notifications.")

  (defun lumen-debug-message (msg)
    "Print if Emacs is started with the --debug-init flag."
    (when debug-on-error
      (message "Lumen debug: %s" msg)))

  (defun lumen-apply-colorscheme ()
    "Apply colorscheme based on `lumen-background`."
    (let ((colorscheme
	   (cond
	    ((string= lumen-background "light") "modus-operandi-tinted")
	    ((string= lumen-background "dark") "modus-vivendi-tinted")
	    (t "")))) ;; Default to no colorscheme if not matching

      (when (and (not (string-empty-p colorscheme))
		 (not (string= (car custom-enabled-themes) colorscheme)))
	(lumen-debug-message (format "Applying colorscheme: %s" colorscheme))
	(load-theme (intern colorscheme) t))))

  (defun lumen-light-hook ()
    "Hook to apply light background color scheme."
    (lumen-debug-message (format "Lumen light hook: Current background %s, desired %s"
				 (frame-parameter nil 'background) "light"))
    (unless (and (string= lumen-background "light")
		 (string= (frame-parameter nil 'background) lumen-background))
      (set-frame-parameter nil 'background "light")
      (setq lumen-background (frame-parameter nil 'background))
      (lumen-debug-message "Lumen light hook: Background set to light")
      (lumen-apply-colorscheme))
    (run-hooks 'lumen-light-hook))

  (defun lumen-dark-hook ()
    "Hook to apply dark background color scheme."
    (lumen-debug-message (format "Lumen dark hook: Current background %s, desired %s"
				 (frame-parameter nil 'background) "dark"))
    (unless (and (string= lumen-background "dark")
		 (string= (frame-parameter nil 'background) lumen-background))
      (set-frame-parameter nil 'background "dark")
      (setq lumen-background (frame-parameter nil 'background))
      (lumen-debug-message "Lumen dark hook: Background set to dark")
      (lumen-apply-colorscheme))
    (run-hooks 'lumen-dark-hook))

  (defun lumen-oneshot ()
    "Run one-shot commands for Linux platforms."
    (lumen-debug-message "Lumen oneshot: Running Linux-specific one-shot command...")
    (let ((out (string-trim (shell-command-to-string
			     (format "%s call -t 1 --session --dest=org.freedesktop.portal.Desktop --object-path=/org/freedesktop/portal/desktop --method=org.freedesktop.portal.Settings.Read org.freedesktop.appearance color-scheme"
				     (executable-find "gdbus"))))))
      (lumen-debug-message (format "Lumen oneshot: Output %s" out))
      (if (string-match "(<<uint32 " out)
	  (let ((val (string-to-number (substring out 10 11))))
	    (setq lumen-background (if (or (= val 2) (= val 0)) "light" "dark"))
	    (lumen-apply-colorscheme))
	(lumen-debug-log-err out))))

  (defun lumen-parse-output (line)
    "Parse output from job."
    (lumen-debug-message (format "Lumen parse output: %s" line))
    (lumen-platforms-linux-parse-line line))

  (defun lumen-on-stdout (process output)
    "Handle standard output from job."
    (let ((data (split-string output "\n" t)))
      (lumen-debug-message (format "Lumen on stdout: %s" output))
      (setq lumen-lines (append lumen-lines data))
      (while (> (length lumen-lines) 1)
	(let ((line (car lumen-lines)))
	  (setq lumen-lines (cdr lumen-lines))
	  (lumen-debug-message (format "Lumen processing line: %s" line))
	  (lumen-parse-output line)))))

  (defun lumen-out-cb (channel msg)
    "Callback for standard output."
    (lumen-debug-message (format "Lumen out cb: %s" msg))
    (lumen-parse-output msg))

  (defun lumen-on-stderr (process output)
    "Handle standard error from job."
    (let ((data (split-string output "\n" t)))
      (lumen-debug-message (format "Lumen on stderr: %s" output))
      (setq lumen-elines (append lumen-elines data))
      (while (> (length lumen-elines) 1)
	(let ((line (car lumen-elines)))
	  (setq lumen-elines (cdr lumen-elines))
	  (lumen-debug-log-err line)))))

  (defun lumen-err-cb (channel msg)
    "Callback for standard error."
    (lumen-debug-message (format "Lumen err cb: %s" msg))
    (lumen-debug-log-err msg))

  (defun lumen-on-exit (process status)
    "Handle job exit."
    (let ((code (process-exit-status process)))
      (lumen-debug-message (format "Lumen on exit: Job %s exited with code %d" process code))
      (setq lumen-exit-code code)))

  (defun lumen-exit-cb (job code)
    "Callback for job exit."
    (lumen-debug-message (format "Lumen exit cb: Job %s exited with code %d" job code))
    (setq lumen-exit-code code))

  (defun lumen-fork-job ()
    "Fork a job to run the command."
    (remove-hook 'after-init-hook 'lumen-fork-job)
    (lumen-debug-message "Lumen fork job: Removing hook and starting job...")
    (let ((command (lumen-platforms-linux-watch-cmd)))
      (lumen-debug-message (format "Lumen fork job: Command is %s" (string-join command " ")))
      (when command
	(let ((proc (apply #'start-process "lumen-job" nil command)))
	  (set-process-filter proc #'lumen-on-stdout)
	  (set-process-sentinel proc #'lumen-on-exit)))))

  (defun lumen-job-state ()
    "Get current job state."
    (let ((res ""))
      (let ((pid (when (< lumen-exit-code 0) (process-id (get-process "lumen-job")))))
	(setq res (if pid (format "run as PID %d" pid) "dead")))
      (when (> lumen-exit-code -1)
	(setq res (concat res (format " (exit code %d)" lumen-exit-code))))
      (lumen-debug-message (format "Lumen job state: %s" res))
      res))

  (defun lumen-platforms-linux-watch-cmd ()
    "Command to listens for interrupts and/or signals from D-Bus on Linux platforms."
    (let ((gdbus-path (executable-find "gdbus")))  ;; Find the gdbus executable
      (if gdbus-path
	  (list gdbus-path
		"monitor"
		"--session"
		"--dest" "org.freedesktop.portal.Desktop"
		"--object-path" "/org/freedesktop/portal/desktop")
	(error "gdbus not found in PATH"))))

  (defun lumen-platforms-linux-parse-line (line)
    "Parse line output from D-Bus."
    (lumen-debug-message (format "Lumen platforms linux parse line: %s" line))
    (when (string-prefix-p lumen-watched-line line)
      (let ((val (- (aref line (- (length line) 3)) 48)))
	(lumen-debug-message (format "Lumen parsed value: %d" val))
	(cond ((or (= val 2) (= val 0))
	       (lumen-light-hook))
	      ((= val 1) (lumen-dark-hook))))))

  (defun lumen-debug-log-err (msg)
    "Log an error message."
    (lumen-debug-message (format "Lumen error: %s" msg)))

  (defun lumen-init ()
    "Initialize Lumen configuration."
    (lumen-debug-message "Lumen init: Starting...")
    (unless (bound-and-true-p lumen-startup-overwrite)
      (setq lumen-startup-overwrite t))
    (lumen-debug-message (format "Lumen init: startup-overwrite set to %s" lumen-startup-overwrite))
    (when lumen-startup-overwrite
      (lumen-oneshot))
    (add-hook 'after-init-hook 'lumen-fork-job)
    (lumen-debug-message "Lumen init: Hook added."))

  (lumen-init)
#+end_src
